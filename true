import os
import sys
import requests
from urllib.parse import quote
from dotenv import load_dotenv

# Chargement des variables d'environnement
load_dotenv()

# Configuration
DOKUWIKI_URL = os.getenv('DOKUWIKI_URL')
DOKUWIKI_TOKEN = os.getenv('DOKUWIKI_TOKEN')

# Timeout for requests in seconds
REQUEST_TIMEOUT = 10

# Configuration pour l'affichage immédiat des logs
import sys

def print_flush(*args, **kwargs):
    print(*args, **kwargs)
    sys.stdout.flush()

def sanitize_pagename(name):
    """Convertit un nom de fichier en un nom de page DokuWiki valide."""
    return name.replace(' ', '_').lower()

def get_file_content(file_path):
    """Lit le contenu d'un fichier."""
    with open(file_path, 'r', encoding='utf-8') as file:
        return file.read()

def page_exists(pagename):
    """Vérifie si une page existe déjà sur le wiki."""
    url = f"{DOKUWIKI_URL}/lib/exe/xmlrpc.php"
    headers = {
        'Content-Type': 'application/xml',
        'Authorization': f'Bearer {DOKUWIKI_TOKEN}'
    }
    
    xml_template = f"""
    <?xml version="1.0"?>
    <methodCall>
      <methodName>wiki.getPage</methodName>
      <params>
        <param><value><string>{pagename}</string></value></param>
      </params>
    </methodCall>
    """
    
    response = requests.post(url, data=xml_template, headers=headers)
    return response.status_code == 200 and response.text.strip() != ''

def create_or_update_page(pagename, content):
    """Crée ou met à jour une page sur le wiki."""
    url = f"{DOKUWIKI_URL}/lib/exe/xmlrpc.php"
    headers = {
        'Content-Type': 'application/xml',
        'Authorization': f'Bearer {DOKUWIKI_TOKEN}'
    }
    
    action = "mise à jour" if page_exists(pagename) else "création"
    
    xml_template = f"""
    <?xml version="1.0"?>
    <methodCall>
      <methodName>wiki.putPage</methodName>
      <params>
        <param><value><string>{pagename}</string></value></param>
        <param><value><string>{content}</string></value></param>
        <param><value><struct>
          <member>
            <name>sum</name>
            <value><string>{action.capitalize()} automatique</string></value>
          </member>
        </struct></value></param>
      </params>
    </methodCall>
    """
    
    try:
        response = requests.post(url, data=xml_template, headers=headers, timeout=10)
        if response.status_code == 200:
            print_flush(f"Page '{pagename}' {action} avec succès.")
            # Vérification supplémentaire
            if page_exists(pagename):
                print_flush(f"Vérification réussie : La page '{pagename}' existe sur le wiki.")
            else:
                print_flush(f"Avertissement : La page '{pagename}' n'existe pas après la {action}.")
        else:
            print_flush(f"Erreur lors de la {action} de la page '{pagename}': {response.status_code}")
            print_flush(f"Réponse du serveur: {response.text}")
    except requests.exceptions.RequestException as e:
        print_flush(f"Erreur lors de la {action} de la page '{pagename}': {str(e)}")
    
    # Affichage de l'URL de la page
    page_url = f"{DOKUWIKI_URL}/doku.php?id={quote(pagename.replace(':', '%3A'))}"
    print_flush(f"URL de la page : {page_url}")

def test_connection():
    """Teste la connexion au wiki."""
    url = f"{DOKUWIKI_URL}/lib/exe/xmlrpc.php"
    headers = {
        'Content-Type': 'application/xml',
        'Authorization': f'Bearer {DOKUWIKI_TOKEN}'
    }
    
    xml_template = """
    <?xml version="1.0"?>
    <methodCall>
      <methodName>wiki.getVersion</methodName>
    </methodCall>
    """
    
    try:
        response = requests.post(url, data=xml_template, headers=headers, timeout=REQUEST_TIMEOUT)
        if response.status_code == 200:
            print_flush(f"Connexion au wiki réussie. URL: {DOKUWIKI_URL}")
            return True
        else:
            print_flush(f"Échec de la connexion au wiki. Code de statut : {response.status_code}")
            print_flush(f"URL tentée : {DOKUWIKI_URL}")
            return False
    except requests.exceptions.ConnectionError as e:
        print_flush(f"Erreur de connexion : Impossible de se connecter à {DOKUWIKI_URL}")
        print_flush(f"Détails de l'erreur : {str(e)}")
        print_flush("Vérifiez que l'URL du wiki est correcte et que le serveur est en cours d'exécution.")
        return False
    except requests.exceptions.Timeout:
        print_flush(f"Erreur de connexion : Le délai d'attente de {REQUEST_TIMEOUT} secondes a été dépassé.")
        print_flush(f"URL tentée : {DOKUWIKI_URL}")
        print_flush("Le serveur wiki pourrait être surchargé ou inaccessible.")
        return False
    except requests.exceptions.RequestException as e:
        print_flush(f"Erreur lors de la connexion au wiki : {str(e)}")
        print_flush(f"URL tentée : {DOKUWIKI_URL}")
        return False

def create_namespace(namespace):
    """Crée une structure de namespace si elle n'existe pas."""
    parts = namespace.split(':')
    current_namespace = ''
    for part in parts:
        current_namespace = f"{current_namespace}:{part}" if current_namespace else part
        if not page_exists(current_namespace):
            create_or_update_page(current_namespace, f"====== {part.capitalize()} ======\n\nCette page est un espace de noms.")

def read_ignore_patterns(directory):
    """Lit les fichiers .gitignore et .aiderignore et retourne les patterns à ignorer."""
    ignore_patterns = []
    ignore_files = ['.gitignore', '.aiderignore']
    
    for ignore_file in ignore_files:
        file_path = os.path.join(directory, ignore_file)
        if os.path.exists(file_path):
            with open(file_path, 'r') as f:
                ignore_patterns.extend(line.strip() for line in f if line.strip() and not line.startswith('#'))
    
    return ignore_patterns

def should_ignore(file_path, ignore_patterns, base_dir):
    """Vérifie si un fichier doit être ignoré en fonction des patterns."""
    rel_path = os.path.relpath(file_path, base_dir)
    for pattern in ignore_patterns:
        if pattern.endswith('/'):
            # Si le pattern se termine par '/', il s'agit d'un dossier
            if fnmatch.fnmatch(rel_path + '/', pattern) or rel_path.startswith(pattern):
                return True
        elif fnmatch.fnmatch(rel_path, pattern) or fnmatch.fnmatch(os.path.basename(file_path), pattern):
            return True
    return False

def process_directory(directory, wiki_namespace='', ignore_patterns=None, base_dir=None):
    """Parcourt récursivement le répertoire et crée/met à jour les pages correspondantes."""
    if ignore_patterns is None:
        ignore_patterns = read_ignore_patterns(directory)
    
    if base_dir is None:
        base_dir = directory
    
    if wiki_namespace:
        create_namespace(wiki_namespace)
    
    for item in os.listdir(directory):
        item_path = os.path.join(directory, item)
        if should_ignore(item_path, ignore_patterns, base_dir):
            print(f"Ignoré : {item_path}")
            continue
        
        if os.path.isfile(item_path):
            file_name, file_extension = os.path.splitext(item)
            pagename = sanitize_pagename(f"{wiki_namespace}:{file_name}" if wiki_namespace else file_name)
            content = get_file_content(item_path)
            if content is not None:
                create_or_update_page(pagename, content)
            else:
                print(f"Impossible de traiter le fichier {item_path}. Il sera ignoré.")
        elif os.path.isdir(item_path):
            new_namespace = f"{wiki_namespace}:{sanitize_pagename(item)}" if wiki_namespace else sanitize_pagename(item)
            process_directory(item_path, new_namespace, ignore_patterns, base_dir)

def create_index_page(directory, wiki_namespace=''):
    """Crée une page d'index pour le dossier courant."""
    index_content = f"====== Index de {wiki_namespace or 'la racine'} ======\n\n"
    for item in sorted(os.listdir(directory)):
        item_path = os.path.join(directory, item)
        if os.path.isfile(item_path):
            file_name, _ = os.path.splitext(item)
            pagename = sanitize_pagename(f"{wiki_namespace}:{file_name}" if wiki_namespace else file_name)
            index_content += f"  * [[{pagename}|{file_name}]]\n"
        elif os.path.isdir(item_path):
            subdir_name = sanitize_pagename(item)
            subdir_index = f"{wiki_namespace}:{subdir_name}:index" if wiki_namespace else f"{subdir_name}:index"
            index_content += f"  * [[{subdir_index}|{item}]]\n"
    
    create_or_update_page(f"{wiki_namespace}:index" if wiki_namespace else 'index', index_content)

if __name__ == "__main__":
    if not all([DOKUWIKI_URL, DOKUWIKI_TOKEN]):
        print("Erreur : Les informations de connexion au wiki sont manquantes dans le fichier .env")
        print("Assurez-vous que DOKUWIKI_URL et DOKUWIKI_TOKEN sont définis.")
        sys.exit(1)

    if len(sys.argv) != 2:
        print("Usage: python sync_wiki.py <chemin_du_dossier>")
        print("Ce script synchronise le contenu du dossier spécifié avec le wiki DokuWiki.")
        print("Il crée ou met à jour les pages du wiki pour chaque fichier dans le dossier,")
        print("et crée des pages d'index pour chaque sous-dossier.")
        sys.exit(1)
    
    folder_path = sys.argv[1]
    if not os.path.isdir(folder_path):
        print(f"Erreur : Le chemin spécifié '{folder_path}' n'est pas un dossier valide.")
        sys.exit(1)
    
    print("Test de la connexion au wiki...")
    if not test_connection():
        print("Impossible de se connecter au wiki. Vérifiez vos paramètres de connexion et l'état du serveur.")
        sys.exit(1)
    
    print(f"Début de la synchronisation du dossier '{folder_path}' avec le wiki...")
    try:
        ignore_patterns = read_ignore_patterns(folder_path)
        process_directory(folder_path, ignore_patterns=ignore_patterns, base_dir=folder_path)
        create_index_page(folder_path)
        print("Synchronisation terminée avec succès.")
    except Exception as e:
        print(f"Une erreur est survenue lors de la synchronisation : {str(e)}")
        sys.exit(1)
